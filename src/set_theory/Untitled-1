
example {α β γ : Type} (e : α ≃ β) : (α ⊕ γ) ≃ (β ⊕ γ) :=
begin
  have : (α ⊕ γ) ≃ _,
  solve_by_elim [equiv.sum_congr, equiv.refl],
  apply equiv.sum_congr,
  apply e,
  apply equiv.refl
end

@[user_attribute]
meta def equiv_congr_attribute : user_attribute :=
{ name := `equiv_congr,
  descr := "congruence lemmas constructing `equiv`s", }

-- tagging equiv.refl _first_ ensures that it is tried _last_.
attribute [equiv_congr] equiv.refl
attribute [equiv_congr] equiv.sum_congr

meta def build_equiv (ty e : expr) : tactic expr :=
do gs ← get_goals,
   equiv_ty ← to_expr ``(%%ty ≃ _),
   r ← mk_meta_var equiv_ty,
   set_goals [r],
   lemmas ← mk_assumption_set tt [simp_arg_type.expr ``(%%e)] [`equiv_congr],
   trace lemmas,
   solve_by_elim { all_goals := ff, assumptions := return lemmas },
   r ← instantiate_mvars r,
   set_goals gs,
   pure r
